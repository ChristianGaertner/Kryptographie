{"name":"Kryptographie","tagline":"Keep it cool.","body":"# Kryptographie\r\n\r\nLos gehts! Wer nicht weiß was oder wer das ist sollte jetzt aufpassen!\r\n\r\nKryptographie ist die Wissenschaft der Verschlüsselung und befasst sich mit der Geheimhaltung von vertraulichen Informationen.\r\n\r\n\r\n## Doch wie funktioniert das ganze?\r\n\r\nEs gibt viele verschiedene Arten der Verschlüsselung. Hier werden wir uns auf 3 mehr oder weniger simple Verfahren konzentrieren.\r\n\r\n\r\n### Caesar\r\n\r\nCaesar ist zugegeben die einfachste aller Verschlüsselungen und viele bereits aus dem Kindes-Alter bekannt, damals noch mit Dreh-Kärtchen oder ähnlichem.\r\n\r\nBasieren tut diese Verschlüsselungsart auf der Verschiebung von einzelne Buchstaben.\r\n\r\nEin Beispiel:\r\n\r\n`ABCD => BCDE`\r\n\r\nAngewendet wurde der Schlüssel `A => B`, oder einfach nur `B`.\r\n\r\nWie man unschwer erkennen kann, lässt sich das ganze schnell und einfach durchführen (und ebenso schnell zurückrechnen).\r\n\r\nAl­go­rith­mische Darstellung (Pseudo-Code):\r\n\r\n(Buchstaben werden als Zahl dargestellt (A=1, B=2, ..., Z=25).\r\n\r\nBuchstabe `x` soll verschlüsselt werden mit Schlüssel `s`:\r\n\r\n```javascript\r\nV(s,x) = ((int) x +  (int) n) mod 26\r\n```\r\n\r\nUnd entschlüsselt wird dann sehr ähnlich:\r\n\r\n```javascript\r\nE(s,x) = ((int)x - (int) n) mod 26\r\n```\r\n\r\n**Achtung:** Diese Methode funktioniert _nur_ mit Buchstaben im Alphabet _(A-Z)_ und auch nur groß _oder_ klein Buchstaben. Es wird also empfohlen vorher alle Buchstaben in eine Schreibweise zu konvertieren und Leerzeichen zu entfernen.\r\n\r\n```javascript\r\nV(s.toUpperCase(), x.toUpperCase.replace(/\\s+/g, '')) = ((int) x +  (int) n) mod 26\r\nE(s.toUpperCase(), x.toUpperCase.replace(/\\s+/g, '')) = ((int)x - (int) n) mod 26\r\n```\r\nIn diesem Beispiel wurden alle Zeichen erst in Großbuchstaben konvertiert (`.toUpperCase()`) und anschließend wird mit Hilfe von regulären Ausdrücken (_RegEx_) Leerzeichen entfernt (`.replace(/\\s+/g, '')`). Natürlich gibt uns diese Methode noch immer Fehler, wenn Sonderzeichen im Text vorhanden sind.\r\n\r\nEine mögliche Lösung wäre nicht streng der Spezifikation der Caesar Verschlüsselung zu folgen und auf den _ASCII Code_ (_American Standard Code for Information Interchange_) zu setzten und das Alphabet zu verlassen. Anstatt bei Z wieder zu A umzuschlagen wird einfach weiter im ASCII Code gegangen - und somit jedes Zeichen verschlüsseln zu können. Dadurch werden unsere Funktionen auch wieder um ein vielfaches Einfacher:\r\n\r\n```javascript\r\nV(s,x) = (x + n)\r\nE(s,x) = (x - n)\r\n// s & x müssen als Zahl vorliegen (ASCII Code)\r\n```\r\n\r\n\r\n### Vigenère\r\n\r\nUm die Probleme der schnellen und einfach Entschlüsselung des Caesar Chiffres vorzubeugen wurde einige Zeit später die Vigenère Verschlüsselung entwickelt. Jene basiert zwar immer noch auf dem gleichen Prinzip wie Caesar, nämlich dem Verschieben von Buchstaben, aber ist etwas sicherer, da der Schlüssel nicht nur aus einem Buchstaben besteht.\r\n\r\nKonkret sieht das ganze so aus, dass ein Schlüssel **Wort** genutzt wird. Auf den ersten Buchstabe des Klartextes wird der erste Buchstabe des Schlüssel-Wortes angewendet, immer 1. & 1. und 2. & 2.\r\n\r\nBis das Ende des Schlüssel-Wortes erreicht wird. Nun wird wieder mit dem 1. Buchstabe des Schlüssel Wortes angefangen, usw.\r\n\r\nPseudo-Code:\r\n\r\n```javascript\r\nV(s,x) = (x + n) // Caesar!\r\n\r\nfor (index i in klartext) {\r\n  put V(schluessel[i mod schluessel.length], klartext[i])\r\n}\r\n```\r\n\r\nEin Beispiel:\r\n\r\n```javascript\r\nklartext = \"GEHEIMENACHRICHT\"\r\nschluessel = \"KEY\"\r\n// Vigenère ausführen\r\n// stdout:\r\nRJGPNLPSZNMQTHGE\r\n```\r\n\r\n\r\n### RSA\r\n\r\nDer Aufmerksame Leser wird schnell festgestellt haben, dass beide Methoden eine große Schwäche aufweisen - der Transfer des Schlüssels. Eine kleine Darstellung:\r\n\r\n```\r\n\r\n|------|                |-----------|              |---------|\r\n|      |   Cipher       |Böse Hacker|   Cipher     |         |\r\n| Bob  | ===========>   | Cipher+Key| ===========> |  Alice  |\r\n|      |     Key        | =Klartext |      Key     |         |\r\n|------|                |-----------|              |---------|\r\n```\r\n\r\nWie man sieht kann man den Key nicht mit übertragen, da sonst jeder den Cipher entschlüsseln könnte.\r\n\r\nEinmal einen Schlüssel wählen in einem private Gespräch ist meist ebenfalls keine Lösung, da oft nur mit einem Server kommuniziert wird, den man nicht mal eben zu StarBucks einladen kann. Die Lösung lautet asymmetrische Verschlüsselung.\r\n\r\nBisher haben wir uns symmetrische Verschlüsselungs-Methoden angeguckt, ein Schlüssel wird für Ver- und Entschlüsselung genutzt. Eine asymmetrische Herangehensweise, wie _RSA_ sie ist, arbeitet etwas anders.\r\n\r\nHierzu wieder ein kleines Beispiel.\r\n\r\nDer Klartext wird in eine Box gelegt und mit einem Schloss verschlossen. Der Empfänger braucht jetzt den **gleichen** Schlüssel um die Nachricht zu lesen. So hat Caesar funktioniert.\r\n\r\nRSA geht einen anderen Weg.\r\n\r\nZunächst muss ich wissen, _wem_ ich eine Nachricht schicken will. Von dieser Person fordere ich nun ein Schloss an, mit diesem verschließe ich die Box und schicke ihn an den Empfänger. Nur dieser hat den Schlüssel und kann somit als einziger die Box öffnen.\r\n\r\nDas Schloss fungiert als **öffentlicher Schlüssel** und der Schlüssel, der niemanden gegeben wird, fungiert als **privater Schlüssel** - _asymmetrische_.\r\n\r\n\r\nDoch was sind das für Schlüssel auch wieder Buchstaben zum Verschieben - Nein. RSA ist _etwas_ komplexer.\r\n\r\nErzeugen des Schlüssel-Paares:\r\n\r\n* Wählen von zwei Primzahlen `p=11` und `q=13` (in der Realtität sollten dies große Zahlen sein!)\r\n* Ein Teil des öffentlichen Schlüssel `N = p * q = 143`\r\n* Nun wird der zweite Teil des Schlüssels generiert:\r\n\r\nErreicht wird dies mit der eulersche  φ-Funktion:\r\n```\r\nφ(N) = (p - 1)(q - 1)= φ(143) = (11 - 1)(13 - 1) = 120\r\n```\r\n\r\nDer zweite Teil des Schlüssel wird `e` genannt und muss zu `120` teilerfremd sein. Also z.B. `e=23`\r\n\r\n* Der öffentliche Schlüssel ist somit `N=143;e=23`\r\n* Der geheime Schlüssel berechnet sich aus den Inversen zu `e`.\r\n\r\n```\r\ne * d + k * φ(N) = 1 = ggT(e, φ(N))\r\n// Konkret:\r\n23 * d + k * 120 = 1 = ggT(23, 120)\r\n```\r\n\r\n* Nun lässt sich daraus der geheime Schlüssel berechnen: `d=47`\r\n\r\n### Das Verschlüsseln\r\n\r\nDie Klartext Nachricht wird in den folgenden Darstellung stets `m` genannt und die verschlüsselte Nachricht `c`.\r\n\r\n```\r\nc ≡ m^e mod N\r\n// m < N !!\r\n```\r\n\r\nBeispiel (wir verschlüsseln die Zahl 4):\r\n\r\n```\r\n75 ≡ 4^23 mod 143\r\n```\r\n\r\nDiesen Cipher können wir nun getrost verschicken. Auf der anderen Seite kann `c=75` wieder entschlüsselt werden, gegeben man besitzt den geheimen Schlüssel:\r\n\r\n```\r\nm ≡ c^d mod N\r\n```\r\n\r\nKonkret:\r\n\r\n```\r\n4 ≡ 75^47 mod N\r\n```\r\n\r\n\r\nUnd so hat der private Schlüssel `d` nie das System des Empfängers verlassen - nur jener kann die Nachricht lesen. Doch wie sicher ist das System, wenn jeder den öffentlichen Schlüssel `N` kennt, aus dem man meinen privaten Schlüssel errechnet hat.\r\n\r\nIn der Tat lässt sich das ganze knacken, aber es ist sehr schwer. Man muss wissen, aus welchen Primzahlen `N` errechnet worden ist. Dies ist eine komplexe Rechenoperation, wenn wir mit sehr großen Zahlen zu tun haben.\r\n\r\nComputer schaffen es heutzutage problemlos 512 Byte Schlüssel zu knacken.\r\n\r\nVorgehensweise:\r\n\r\nAlle Primzahlen kenn bis `sqrt(N)` und folgenden Pseudo-Code ausführen:\r\n\r\n```javascript\r\n\r\nfor (p in primes.until(sqrt(N)) {\r\n   q = N / p\r\n   if (primes.contains(q)) {\r\n      return {p, q} // Geknackt\r\n   }\r\n}\r\n```\r\n\r\nProblem hierbei ist natürlich, dass die Anzahl der Rechenoperation stark steigt, je größer N ist.\r\n\r\nMomentan können 4096 Byte Schlüssel noch nicht geknackt werden, aber vorraus gesagt wurde, dass es in etwa 10 Jahren durchaus möglich ist. Unsere Daten sind also auf Zeit sicher.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}